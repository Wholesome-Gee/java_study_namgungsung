package basic; // 상속

/**
* [핵심 요약]
	1. 상속(Inheritance)이란? (00:00:08)
		- 기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것입니다. [00:00:12]
		- `extends` 키워드를 사용하여 부모-자식 관계를 맺어줍니다. [00:00:36]
	2. 상속의 특징 (00:01:52)
		- 자손은 조상의 **모든 멤버**를 상속받습니다. (단, 생성자와 초기화 블록은 제외) [00:02:51]
		- 자손의 멤버 개수는 조상의 멤버 개수보다 항상 같거나 많습니다. [00:03:07]
		- 조상의 변경은 자손에게 영향을 미치지만, 자손의 변경은 조상에게 영향을 주지 않습니다. [00:05:02]
	3. 포함 vs 상속 (영상 후반부 예고)
		- 상속은 '확장(extends)'의 개념이므로, 부모의 기능을 그대로 쓰면서 새로운 기능을 추가할 때 매우 유리합니다. [00:06:22]
*/

class Tv {
  boolean power; // 전원상태(on/off)
  int channel;   // 채널

  void power() { power = !power; }
  void channelUp() { ++channel; }
  void channelDown() { --channel; }
}

// Tv 클래스를 상속받은 SmartTv [00:12:35]
class SmartTv extends Tv { 
  boolean caption; // 자막 상태(on/off)
  
  void displayCaption(String text) {
  	if (caption) { // 자막 상태가 on일 때만 자막을 보여준다.
  	  System.out.println(text);
  	}
  }
}

public class Chapter070 {
  public static void main(String[] args) {
  	SmartTv stv = new SmartTv();
  	
  	// 부모(Tv)로부터 상속받은 멤버들 사용 가능 [00:13:36]
  	stv.channel = 10;       // 조상 클래스의 변수
  	stv.channelUp();        // 조상 클래스의 메서드
  	System.out.println("현재 채널: " + stv.channel);
  	
  	// 자식(SmartTv)만의 고유 멤버 사용
  	stv.caption = true;
  	stv.displayCaption("Hello, Inheritance!");
  }
}

/**
 * [Gemini의 꼼꼼한 보충수업]
	1. 왜 상속을 쓰나요? (00:11:51)
		- 3차원 좌표(Point3D)를 만들 때 2차원(Point)을 상속받으면 x, y를 다시 정의할 필요가 없습니다. [00:07:52]
		- 코드의 중복이 줄어들고, 공통적인 부분은 부모 클래스에서 한 번에 관리할 수 있어 유지보수가 편해집니다. [00:12:03]
	2. 자손은 조상의 모든 멤버를 받는다? (00:02:35)
		- 조상의 부모(조부모) 클래스가 있다면 그 멤버까지도 모두 내려받습니다. 그래서 '부모'보다는 '조상'이라는 용어를 씁니다. [00:02:21]
	3. 주의할 점 (00:14:05)
		- 부모 클래스의 멤버를 삭제하거나 변경하면, 이를 상속받은 모든 자식 클래스에서 에러가 발생하거나 동작이 변하므로 주의해야 합니다. [00:14:48]
 */

/**
* [실무 꿀팁 - 객체지향 설계 편]
	1. 'IS-A' 관계를 확인하세요
		- 상속은 "자식은 부모이다(SmartTv is a Tv)"라는 관계가 성립할 때만 사용하는 것이 원칙입니다.
		- 억지로 코드를 재사용하려고 상속을 남발하면 클래스 간 결합도가 너무 높아져 나중에 수정하기 힘들어집니다.
	2. 상속 깊이는 적당히
		- 조상의 조상의 조상... 식으로 상속 계층이 너무 깊어지면 코드를 추적하기 매우 어려워집니다. 보통 2~3단계 정도가 적당합니다.
	3. 생성자는 상속되지 않습니다! (00:02:51 참고)
		- 실무에서 자주 하는 실수 중 하나인데, 부모의 생성자는 상속되지 않으므로 자식 클래스에서 필요하다면 `super()` 등을 통해 직접 처리해줘야 합니다.
*/