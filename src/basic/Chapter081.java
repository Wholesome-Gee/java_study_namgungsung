package basic; // 81. 참조변수의 형변환

/**
* [핵심 요약]
	1. 참조변수의 형변환이란? (00:00:10)
		- 사용할 수 있는 멤버의 개수를 조절하는 것입니다. [00:00:18]
		- 주소값이나 객체 자체는 전혀 변하지 않습니다. [00:01:00]
	2. 형변환의 조건 (00:01:25)
		- 서로 상속관계에 있는 클래스 사이에서만 가능합니다. [00:01:32]
		- 형제 관계(같은 부모를 둔 자식들끼리)는 형변환이 불가능합니다. [00:02:04]
	3. 업캐스팅 vs 다운캐스팅 (00:05:22)
		- 업캐스팅(자손->조상): 멤버 개수가 줄어들므로 안전하여 형변환 생략이 가능합니다. [00:16:35]
		- 다운캐스팅(조상->자손): 멤버 개수가 늘어날 수 있어 위험하므로 형변환을 명시해야 합니다. [00:17:01]
*/

class Car {
  String color;
  int door;
  void drive() { System.out.println("drive, Brrr~"); }
  void stop() { System.out.println("stop!!!"); }
}

class FireEngine extends Car {
  void water() { System.out.println("water!!!"); }
}

public class Chapter081 {
  public static void main(String[] args) {
  	Car car = null;
  	FireEngine fe = new FireEngine();
  	FireEngine fe2 = null;

  	fe.water(); // 자손 타입은 자기 기능 사용 가능 [00:14:10]

  	// 1. 업캐스팅 (자손 -> 조상): 생략 가능 [00:04:37]
  	car = (Car)fe; // car = fe; 와 같음. 멤버 5개 -> 4개로 제한 [00:07:49]
  	// car.water(); // 에러! Car 타입 리모컨에는 water 버튼이 없음 [00:15:12]

  	// 2. 다운캐스팅 (조상 -> 자손): 생략 불가 [00:15:22]
  	fe2 = (FireEngine)car; // 멤버 4개 -> 5개로 확장. 명시적 형변환 필요 [00:18:00]
  	fe2.water(); // 다시 자손 타입으로 변환했으므로 water 사용 가능 [00:18:32]
  }
}

/**
 * [Gemini의 꼼꼼한 보충수업]
	1. 왜 멤버 개수를 조절하나? (00:10:18)
		- 똑같은 객체를 가리키더라도, 어떤 타입의 참조변수를 쓰느냐에 따라 우리가 사용할 수 있는 기능의 범위가 달라집니다. [00:07:52]
	2. 형변환 연산자 (type) (00:04:32)
		- 타입이 일치하지 않을 때 양변을 맞춰주기 위해 사용합니다. 
		- 조상으로 갈 때는 "안전하니까 그냥 가라(생략)", 자손으로 올 때는 "진짜 이 기능 다 있어? 확인해!(명시)"라고 이해하면 좋습니다. [00:17:21]
	3. 형제 관계 주의 (00:10:48)
		- 소방차(FireEngine)와 앰뷸런스(Ambulance)는 둘 다 자동차(Car)지만, 소방차 리모컨으로 앰뷸런스를 다룰 수는 없습니다. 상속 관계만 확인하세요! [00:11:53]
 */

/**
* [실무 꿀팁 - 형변환 편]
	1. 안전제일 (00:16:43)
		- 멤버 개수가 줄어드는 방향은 항상 안전합니다. 하지만 늘어나는 방향은 실제 객체에 그 기능이 없을 수도 있기 때문에 위험하며, 반드시 형변환을 써줘야 합니다. [00:17:07]
	2. 헷갈릴 때는? (00:05:12)
		- 업캐스팅/다운캐스팅 용어에 너무 집착하지 마세요. "조상-자손 관계인가?" 그리고 "타입이 맞는가?"만 체크하면 됩니다. [00:05:36]
	3. 컴파일러의 경고
		- 형변환을 빼먹으면 컴파일러가 친절하게 알려줍니다. 그때 조상 타입인지 자손 타입인지 확인하고 적절히 대응하면 됩니다. [00:09:16]
*/