package basic; // 오버라이딩

/**
* [핵심 요약]
	1. 오버라이딩(Overriding)이란? (00:00:08)
		- 조상 클래스로부터 상속받은 메서드의 내용을 자신에 맞게 변경하는 것입니다. [00:00:32]
		- 'Override'는 '~위에 덮어쓰다'는 의미를 가지고 있습니다.
	2. 오버라이딩의 조건 (00:12:17)
		- 자손 클래스에서 오버라이딩하는 메서드는 조상 클래스의 메서드와 **선언부가 일치**해야 합니다. [00:12:42]
			* 메서드 이름, 매개변수 목록, 반환 타입이 모두 같아야 함.
		- 접근 제어자는 조상 클래스의 메서드보다 좁은 범위로 변경할 수 없습니다. [00:13:10]
		- 조상 클래스의 메서드보다 많은 수의 예외를 선언할 수 없습니다. [00:15:07]
	3. 오버로딩 vs 오버라이딩 (00:15:27)
		- 오버로딩: 기존에 없는 새로운 메서드를 정의하는 것 (New) [00:16:01]
		- 오버라이딩: 상속받은 메서드의 내용을 변경하는 것 (Change/Modify) [00:16:23]
*/

class MyPoint3 {
  int x;
  int y;

  MyPoint3(int x, int y) {
  	this.x = x;
  	this.y = y;
  }

  // Object 클래스의 toString()을 오버라이딩 [00:07:53]
  public String toString() {
  	return "x:" + x + ", y:" + y;
  }
}

public class Chapter073 {
  public static void main(String[] args) {
  	MyPoint3 p = new MyPoint3(1, 2);
  	
  	// 오버라이딩된 toString()이 호출됨 [00:09:40]
  	System.out.println(p.toString());
  	
  	// 참조변수만 출력해도 자동으로 toString() 호출 [00:11:04]
  	System.out.println(p); 
  }
}

/**
 * [Gemini의 꼼꼼한 보충수업]
	1. 왜 오버라이딩을 하나요? (00:01:42)
		- 2차원 좌표(Point)의 `getLocation()`은 x, y만 출력하지만, 3차원(Point3D)은 z까지 출력해야 합니다. [00:02:03]
		- 이때 메서드 이름을 새로 만들기보다 조상의 것을 고쳐 쓰는 것이 사용자 입장에서 훨씬 직관적입니다. [00:03:01]
	2. toString() 오버라이딩의 편리함 (00:10:21)
		- 오버라이딩 전에는 멤버 변수 값을 확인하려면 `p.x`, `p.y`를 일일이 찍어야 했지만, 재정의 후에는 객체 이름만 출력하면 한 번에 확인이 가능합니다. [00:11:45]
	3. 호출의 우선순위 (00:06:52)
		- 상속 관계에서 메서드가 호출되면, 항상 '가장 하위 자식'에서 오버라이딩된 메서드가 우선적으로 실행됩니다. [00:07:14]
 */

/**
* [실무 꿀팁 - 메서드 재정의 편]
	1. @Override 애너테이션을 꼭 사용하세요
		- 영상에서는 생략되었지만, 실무에서는 메서드 위에 `@Override`를 붙입니다. 
		- 만약 오타를 내서 선언부가 달라지면 컴파일러가 "이건 오버라이딩이 아니야!"라고 즉시 알려주어 실수를 방지합니다.
	2. IDE의 자동 생성 기능을 활용하세요
		- IntelliJ나 Eclipse에서 `Alt + Insert` (또는 `Cmd + N`)를 누르면 `toString()`, `equals()` 등을 완벽한 조건으로 자동 오버라이딩해 줍니다.
	3. 조상의 기능을 완전히 버리지 마세요 (super)
		- 조상의 로직을 유지하면서 기능만 살짝 추가하고 싶을 때는 `super.methodName()`을 사용하여 조상의 코드를 호출한 뒤 내 코드를 덧붙이는 방식을 자주 씁니다.
*/