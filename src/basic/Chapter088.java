package basic; // 88. 추상 클래스의 작성 2

/**
* [핵심 요약]
	1. 추상 클래스의 장점 (00:01:46)
		- 중복 제거: 공통 기능을 조상에서 관리하여 코드 중복을 없앱니다. [00:01:52]
		- 관리 용이: 조상 클래스만 수정하면 상속받은 모든 자손 클래스에 자동 반영됩니다. [00:03:02]
		- 작성 편의: 미완성 설계도를 바탕으로 새로운 모델을 빠르게 만들 수 있습니다. [00:02:24]
	2. 단계별 추상화 (00:03:14)
		- 추상 클래스를 여러 단계로 구성하여, 필요에 따라 원하는 단계를 선택해 상속받을 수 있습니다. [00:05:11]
	3. 추상화 vs 구체화 (00:06:13)
		- 구체화: 구체적이고 명확하게 만드는 것 (예: new GregorianCalendar()) [00:07:50]
		- 추상화: 불분명하고 애매하게 만드는 것 (예: Calendar.getInstance()) [00:08:37]
	4. 추상화의 위력 (00:07:44)
		- 추상적인 코드는 구체적인 코드보다 훨씬 **유연**합니다. [00:07:34]
		- 호출하는 쪽에서는 어떤 객체가 올지 몰라도(애매해도) 사용법만 알면 됩니다. [00:12:22]
*/

import java.util.Calendar;
import java.util.GregorianCalendar;

// 추상 클래스의 단계별 관리 예시 [00:03:33]
abstract class Electronics { // 1단계: 전자제품 공통
  abstract void on();
}

abstract class Tv extends Electronics { // 2단계: TV 공통 기능 추가
  abstract void channelUp();
}

class SmartTv extends Tv { // 3단계: 구체적인 제품 완성
  void on() { System.out.println("TV 전원을 켭니다."); }
  void channelUp() { System.out.println("채널을 올립니다."); }
}

public class Chapter088 {
  public static void main(String[] args) {
  	// 1. 구체적인 코드: 변경에 취약함 [00:07:50]
  	GregorianCalendar cal1 = new GregorianCalendar(); // 서양력으로 고정됨
  	
  	// 2. 추상적인 코드: 변경에 매우 유리함 (유연함) [00:08:37]
  	// Calendar는 추상 클래스이지만 getInstance()를 통해 
  	// 실행 환경(국가, OS 설정 등)에 맞는 자손 객체를 알아서 반환합니다. [00:10:01]
  	Calendar cal2 = Calendar.getInstance(); 
  	
  	System.out.println("현재 연도: " + cal2.get(Calendar.YEAR));
  }
}

/**
 * [Gemini의 꼼꼼한 보충수업]
	1. "애매한 게 좋다?" (00:07:11)
		- 실생활에서는 명확한 게 좋지만, 프로그래밍에서는 코드를 너무 구체적으로 짜놓으면 나중에 수정할 때 수만 줄의 코드를 다 고쳐야 합니다. [00:07:13]
		- 추상화를 통해 "뭐가 올진 모르겠지만, 이런 기능은 있을 거야"라고 약속만 해두면 나중에 알맹이(객체)를 바꿔 끼우기 매우 쉬워집니다. [00:13:03]
	2. 추상화와 다형성 (00:09:09)
		- `Calendar.getInstance()`가 자손 객체(서양력, 불교력 등)를 반환해도 `Calendar` 타입으로 받을 수 있는 이유는 바로 '다형성' 덕분입니다. [00:09:10]
	3. 공부 방법 제안 (00:13:51)
		- 지금 당장 100% 이해되지 않는 것이 당연합니다. [00:13:27]
		- 완벽히 이해될 때까지 멈춰있지 말고, 계속 진도를 나가며 실제 적용된 사례들을 만나다 보면 어느 순간 무릎을 탁 치며 이해되는 시점이 올 것입니다. [00:14:05]
 */

/**
* [실무 꿀팁 - 추상화의 실체]
	1. 캡슐화와 변경 (00:12:44)
		- `getInstance()` 내부 로직이 바뀌어도, 이 메서드를 가져다 쓰는 `main` 코드는 단 한 줄도 고칠 필요가 없습니다. 이것이 추상화가 주는 최고의 선물입니다. [00:12:55]
	2. 라이브러리 설계 (00:11:19)
		- 자바 표준 라이브러리의 많은 부분이 이런 추상화 원리를 이용해 설계되어 있습니다. 사용자는 복잡한 내부 구현을 몰라도 추상화된 메서드만 알면 됩니다. [00:11:35]
	3. 반복과 실습 (00:14:13)
		- 이해가 안 갈수록 코드를 직접 타이핑해 보며 손에 익히는 것이 가장 빠른 지름길입니다. [00:14:17]
*/